import machine
from machine import Pin , I2C
import utime

from ustruct import pack
from array import array

from micropython import const
import framebuf


# register definitions
SET_CONTRAST = const(0x81)
SET_ENTIRE_ON = const(0xA4)
SET_NORM_INV = const(0xA6)
SET_DISP = const(0xAE)
SET_MEM_ADDR = const(0x20)
SET_COL_ADDR = const(0x21)
SET_PAGE_ADDR = const(0x22)
SET_DISP_START_LINE = const(0x40)
SET_SEG_REMAP = const(0xA0)
SET_MUX_RATIO = const(0xA8)
SET_COM_OUT_DIR = const(0xC0)
SET_DISP_OFFSET = const(0xD3)
SET_COM_PIN_CFG = const(0xDA)
SET_DISP_CLK_DIV = const(0xD5)
SET_PRECHARGE = const(0xD9)
SET_VCOM_DESEL = const(0xDB)
SET_CHARGE_PUMP = const(0x8D)



BasicFont[]= [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E,
		0x5B, 0x4F, 0x5B, 0x3E, 0x3E, 0x6B, 0x4F, 0x6B, 0x3E, 0x1C, 0x3E, 0x7C,
		0x3E, 0x1C, 0x18, 0x3C, 0x7E, 0x3C, 0x18, 0x1C, 0x57, 0x7D, 0x57, 0x1C,
		0x1C, 0x5E, 0x7F, 0x5E, 0x1C, 0x00, 0x18, 0x3C, 0x18, 0x00, 0xFF, 0xE7,
		0xC3, 0xE7, 0xFF, 0x00, 0x18, 0x24, 0x18, 0x00, 0xFF, 0xE7, 0xDB, 0xE7,
		0xFF, 0x30, 0x48, 0x3A, 0x06, 0x0E, 0x26, 0x29, 0x79, 0x29, 0x26, 0x40,
		0x7F, 0x05, 0x05, 0x07, 0x40, 0x7F, 0x05, 0x25, 0x3F, 0x5A, 0x3C, 0xE7,
		0x3C, 0x5A, 0x7F, 0x3E, 0x1C, 0x1C, 0x08, 0x08, 0x1C, 0x1C, 0x3E, 0x7F,
		0x14, 0x22, 0x7F, 0x22, 0x14, 0x5F, 0x5F, 0x00, 0x5F, 0x5F, 0x06, 0x09,
		0x7F, 0x01, 0x7F, 0x00, 0x66, 0x89, 0x95, 0x6A, 0x60, 0x60, 0x60, 0x60,
		0x60, 0x94, 0xA2, 0xFF, 0xA2, 0x94, 0x08, 0x04, 0x7E, 0x04, 0x08, 0x10,
		0x20, 0x7E, 0x20, 0x10, 0x08, 0x08, 0x2A, 0x1C, 0x08, 0x08, 0x1C, 0x2A,
		0x08, 0x08, 0x1E, 0x10, 0x10, 0x10, 0x10, 0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
		0x30, 0x38, 0x3E, 0x38, 0x30, 0x06, 0x0E, 0x3E, 0x0E, 0x06, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x07, 0x00, 0x07,
		0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14, 0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x23,
		0x13, 0x08, 0x64, 0x62, 0x36, 0x49, 0x56, 0x20, 0x50, 0x00, 0x08, 0x07,
		0x03, 0x00, 0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x41, 0x22, 0x1C, 0x00,
		0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x80,
		0x70, 0x30, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x60, 0x60,
		0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00,
		0x42, 0x7F, 0x40, 0x00, 0x72, 0x49, 0x49, 0x49, 0x46, 0x21, 0x41, 0x49,
		0x4D, 0x33, 0x18, 0x14, 0x12, 0x7F, 0x10, 0x27, 0x45, 0x45, 0x45, 0x39,
		0x3C, 0x4A, 0x49, 0x49, 0x31, 0x41, 0x21, 0x11, 0x09, 0x07, 0x36, 0x49,
		0x49, 0x49, 0x36, 0x46, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00, 0x14, 0x00,
		0x00, 0x00, 0x40, 0x34, 0x00, 0x00, 0x00, 0x08, 0x14, 0x22, 0x41, 0x14,
		0x14, 0x14, 0x14, 0x14, 0x00, 0x41, 0x22, 0x14, 0x08, 0x02, 0x01, 0x59,
		0x09, 0x06, 0x3E, 0x41, 0x5D, 0x59, 0x4E, 0x7C, 0x12, 0x11, 0x12, 0x7C,
		0x7F, 0x49, 0x49, 0x49, 0x36, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x7F, 0x41,
		0x41, 0x41, 0x3E, 0x7F, 0x49, 0x49, 0x49, 0x41, 0x7F, 0x09, 0x09, 0x09,
		0x01, 0x3E, 0x41, 0x41, 0x51, 0x73, 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00,
		0x41, 0x7F, 0x41, 0x00, 0x20, 0x40, 0x41, 0x3F, 0x01, 0x7F, 0x08, 0x14,
		0x22, 0x41, 0x7F, 0x40, 0x40, 0x40, 0x40, 0x7F, 0x02, 0x1C, 0x02, 0x7F,
		0x7F, 0x04, 0x08, 0x10, 0x7F, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x7F, 0x09,
		0x09, 0x09, 0x06, 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x7F, 0x09, 0x19, 0x29,
		0x46, 0x26, 0x49, 0x49, 0x49, 0x32, 0x03, 0x01, 0x7F, 0x01, 0x03, 0x3F,
		0x40, 0x40, 0x40, 0x3F, 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x3F, 0x40, 0x38,
		0x40, 0x3F, 0x63, 0x14, 0x08, 0x14, 0x63, 0x03, 0x04, 0x78, 0x04, 0x03,
		0x61, 0x59, 0x49, 0x4D, 0x43, 0x00, 0x7F, 0x41, 0x41, 0x41, 0x02, 0x04,
		0x08, 0x10, 0x20, 0x00, 0x41, 0x41, 0x41, 0x7F, 0x04, 0x02, 0x01, 0x02,
		0x04, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x03, 0x07, 0x08, 0x00, 0x20,
		0x54, 0x54, 0x78, 0x40, 0x7F, 0x28, 0x44, 0x44, 0x38, 0x38, 0x44, 0x44,
		0x44, 0x28, 0x38, 0x44, 0x44, 0x28, 0x7F, 0x38, 0x54, 0x54, 0x54, 0x18,
		0x00, 0x08, 0x7E, 0x09, 0x02, 0x18, 0xA4, 0xA4, 0x9C, 0x78, 0x7F, 0x08,
		0x04, 0x04, 0x78, 0x00, 0x44, 0x7D, 0x40, 0x00, 0x20, 0x40, 0x40, 0x3D,
		0x00, 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x41, 0x7F, 0x40, 0x00, 0x7C,
		0x04, 0x78, 0x04, 0x78, 0x7C, 0x08, 0x04, 0x04, 0x78, 0x38, 0x44, 0x44,
		0x44, 0x38, 0xFC, 0x18, 0x24, 0x24, 0x18, 0x18, 0x24, 0x24, 0x18, 0xFC,
		0x7C, 0x08, 0x04, 0x04, 0x08, 0x48, 0x54, 0x54, 0x54, 0x24, 0x04, 0x04,
		0x3F, 0x44, 0x24, 0x3C, 0x40, 0x40, 0x20, 0x7C, 0x1C, 0x20, 0x40, 0x20,
		0x1C, 0x3C, 0x40, 0x30, 0x40, 0x3C, 0x44, 0x28, 0x10, 0x28, 0x44, 0x4C,
		0x90, 0x90, 0x90, 0x7C, 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x08, 0x36,
		0x41, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x00, 0x41, 0x36, 0x08, 0x00,
		0x02, 0x01, 0x02, 0x04, 0x02, 0x3C, 0x26, 0x23, 0x26, 0x3C, 0x1E, 0xA1,
		0xA1, 0x61, 0x12, 0x3A, 0x40, 0x40, 0x20, 0x7A, 0x38, 0x54, 0x54, 0x55,
		0x59, 0x21, 0x55, 0x55, 0x79, 0x41, 0x21, 0x54, 0x54, 0x78, 0x41, 0x21,
		0x55, 0x54, 0x78, 0x40, 0x20, 0x54, 0x55, 0x79, 0x40, 0x0C, 0x1E, 0x52,
		0x72, 0x12, 0x39, 0x55, 0x55, 0x55, 0x59, 0x39, 0x54, 0x54, 0x54, 0x59,
		0x39, 0x55, 0x54, 0x54, 0x58, 0x00, 0x00, 0x45, 0x7C, 0x41, 0x00, 0x02,
		0x45, 0x7D, 0x42, 0x00, 0x01, 0x45, 0x7C, 0x40, 0xF0, 0x29, 0x24, 0x29,
		0xF0, 0xF0, 0x28, 0x25, 0x28, 0xF0, 0x7C, 0x54, 0x55, 0x45, 0x00, 0x20,
		0x54, 0x54, 0x7C, 0x54, 0x7C, 0x0A, 0x09, 0x7F, 0x49, 0x32, 0x49, 0x49,
		0x49, 0x32, 0x32, 0x48, 0x48, 0x48, 0x32, 0x32, 0x4A, 0x48, 0x48, 0x30,
		0x3A, 0x41, 0x41, 0x21, 0x7A, 0x3A, 0x42, 0x40, 0x20, 0x78, 0x00, 0x9D,
		0xA0, 0xA0, 0x7D, 0x39, 0x44, 0x44, 0x44, 0x39, 0x3D, 0x40, 0x40, 0x40,
		0x3D, 0x3C, 0x24, 0xFF, 0x24, 0x24, 0x48, 0x7E, 0x49, 0x43, 0x66, 0x2B,
		0x2F, 0xFC, 0x2F, 0x2B, 0xFF, 0x09, 0x29, 0xF6, 0x20, 0xC0, 0x88, 0x7E,
		0x09, 0x03, 0x20, 0x54, 0x54, 0x79, 0x41, 0x00, 0x00, 0x44, 0x7D, 0x41,
		0x30, 0x48, 0x48, 0x4A, 0x32, 0x38, 0x40, 0x40, 0x22, 0x7A, 0x00, 0x7A,
		0x0A, 0x0A, 0x72, 0x7D, 0x0D, 0x19, 0x31, 0x7D, 0x26, 0x29, 0x29, 0x2F,
		0x28, 0x26, 0x29, 0x29, 0x29, 0x26, 0x30, 0x48, 0x4D, 0x40, 0x20, 0x38,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x2F, 0x10, 0xC8,
		0xAC, 0xBA, 0x2F, 0x10, 0x28, 0x34, 0xFA, 0x00, 0x00, 0x7B, 0x00, 0x00,
		0x08, 0x14, 0x2A, 0x14, 0x22, 0x22, 0x14, 0x2A, 0x14, 0x08, 0xAA, 0x00,
		0x55, 0x00, 0xAA, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x00, 0x00, 0x00, 0xFF,
		0x00, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x14, 0x14, 0x14, 0xFF, 0x00, 0x10,
		0x10, 0xFF, 0x00, 0xFF, 0x10, 0x10, 0xF0, 0x10, 0xF0, 0x14, 0x14, 0x14,
		0xFC, 0x00, 0x14, 0x14, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0xFF,
		0x14, 0x14, 0xF4, 0x04, 0xFC, 0x14, 0x14, 0x17, 0x10, 0x1F, 0x10, 0x10,
		0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0x1F, 0x00, 0x10, 0x10, 0x10, 0xF0,
		0x00, 0x00, 0x00, 0x00, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x10, 0x10,
		0x10, 0x10, 0xF0, 0x10, 0x00, 0x00, 0x00, 0xFF, 0x10, 0x10, 0x10, 0x10,
		0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x00, 0x00, 0x00, 0xFF, 0x14,
		0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x1F, 0x10, 0x17, 0x00, 0x00,
		0xFC, 0x04, 0xF4, 0x14, 0x14, 0x17, 0x10, 0x17, 0x14, 0x14, 0xF4, 0x04,
		0xF4, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
		0x14, 0xF7, 0x00, 0xF7, 0x14, 0x14, 0x14, 0x17, 0x14, 0x10, 0x10, 0x1F,
		0x10, 0x1F, 0x14, 0x14, 0x14, 0xF4, 0x14, 0x10, 0x10, 0xF0, 0x10, 0xF0,
		0x00, 0x00, 0x1F, 0x10, 0x1F, 0x00, 0x00, 0x00, 0x1F, 0x14, 0x00, 0x00,
		0x00, 0xFC, 0x14, 0x00, 0x00, 0xF0, 0x10, 0xF0, 0x10, 0x10, 0xFF, 0x10,
		0xFF, 0x14, 0x14, 0x14, 0xFF, 0x14, 0x10, 0x10, 0x10, 0x1F, 0x00, 0x00,
		0x00, 0x00, 0xF0, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0,
		0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
		0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x38, 0x44, 0x44, 0x38, 0x44, 0x7C, 0x2A,
		0x2A, 0x3E, 0x14, 0x7E, 0x02, 0x02, 0x06, 0x06, 0x02, 0x7E, 0x02, 0x7E,
		0x02, 0x63, 0x55, 0x49, 0x41, 0x63, 0x38, 0x44, 0x44, 0x3C, 0x04, 0x40,
		0x7E, 0x20, 0x1E, 0x20, 0x06, 0x02, 0x7E, 0x02, 0x02, 0x99, 0xA5, 0xE7,
		0xA5, 0x99, 0x1C, 0x2A, 0x49, 0x2A, 0x1C, 0x4C, 0x72, 0x01, 0x72, 0x4C,
		0x30, 0x4A, 0x4D, 0x4D, 0x30, 0x30, 0x48, 0x78, 0x48, 0x30, 0xBC, 0x62,
		0x5A, 0x46, 0x3D, 0x3E, 0x49, 0x49, 0x49, 0x00, 0x7E, 0x01, 0x01, 0x01,
		0x7E, 0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x44, 0x44, 0x5F, 0x44, 0x44, 0x40,
		0x51, 0x4A, 0x44, 0x40, 0x40, 0x44, 0x4A, 0x51, 0x40, 0x00, 0x00, 0xFF,
		0x01, 0x03, 0xE0, 0x80, 0xFF, 0x00, 0x00, 0x08, 0x08, 0x6B, 0x6B, 0x08,
		0x36, 0x12, 0x36, 0x24, 0x36, 0x06, 0x0F, 0x09, 0x0F, 0x06, 0x00, 0x00,
		0x18, 0x18, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x30, 0x40, 0xFF, 0x01,
		0x01, 0x00, 0x1F, 0x01, 0x01, 0x1E, 0x00, 0x19, 0x1D, 0x17, 0x12, 0x00,
		0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, ]

buffer[128 * 64 / 8] = [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x08, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xC0, 0xF0, 0xF0, 0xF8, 0x78, 0x78, 0xF8, 0xF0, 0xE0, 0xC0,
		0x00, 0xC0, 0xF0, 0xF0, 0xF0, 0x78, 0x78, 0xF0, 0xF0, 0xE0, 0xC0, 0x00,
		0xF0, 0xF0, 0xF0, 0xF0, 0x70, 0x70, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xE0, 0xF0, 0xF0, 0x78,
		0x3C, 0xBC, 0xDE, 0xEF, 0xF7, 0xF0, 0xF8, 0x7C, 0x7E, 0xBF, 0xDF, 0xFF,
		0xEF, 0xFF, 0xF7, 0xF8, 0xFC, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
		0xFF, 0xFF, 0x38, 0x38, 0xFB, 0xFB, 0xFB, 0xFB, 0x00, 0xFF, 0xFF, 0xFF,
		0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
		0x1E, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0,
		0x82, 0x8F, 0x9F, 0x3F, 0x3F, 0x7F, 0x70, 0x66, 0xDF, 0x3F, 0x7F, 0xFF,
		0x03, 0x01, 0x00, 0x1E, 0x3F, 0x7F, 0xFF, 0xFF, 0x3F, 0x3F, 0x1F, 0x1F,
		0x0F, 0x87, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x0F, 0x0F, 0x0F,
		0x07, 0x07, 0x07, 0x07, 0x00, 0x01, 0x07, 0x07, 0x0F, 0x0F, 0x0F, 0x0F,
		0x07, 0x07, 0x01, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x07,
		0x0F, 0x1F, 0x3E, 0x7E, 0x7E, 0xFE, 0xFE, 0x0E, 0x64, 0x78, 0x18, 0x1C,
		0x1C, 0x1C, 0x0C, 0x0C, 0x0C, 0x0E, 0x0E, 0x0E, 0x07, 0x03, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x12, 0x10, 0x38, 0x82,
		0x00, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x68, 0x08, 0xB0,
		0x20, 0x00, 0xF0, 0x90, 0x08, 0x18, 0x90, 0x00, 0x08, 0x08, 0xFE, 0x08,
		0x88, 0x00, 0x08, 0x08, 0xF8, 0x10, 0x08, 0x10, 0x00, 0xF0, 0x10, 0x08,
		0x90, 0xF0, 0x00, 0x08, 0xF8, 0x08, 0x08, 0xF0, 0x00, 0x00, 0x08, 0x0A,
		0xFB, 0x00, 0x00, 0x00, 0xF0, 0x90, 0x08, 0x18, 0x80, 0x00, 0x00, 0xB0,
		0x68, 0x48, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,
		0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01,
		0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,
		0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01,
		0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0,
		0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0xE0, 0x20, 0x20, 0xC0, 0x00, 0x00,
		0xC0, 0xA0, 0xA0, 0xC0, 0x00, 0x00, 0xE0, 0x20, 0x20, 0xE0, 0x00, 0x00,
		0x00, 0x30, 0x48, 0x48, 0x98, 0x00, 0x00, 0xE0, 0x20, 0x20, 0xE0, 0x00,
		0x00, 0xE0, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xE0, 0x20, 0x20, 0x00, 0xC0,
		0x20, 0x20, 0x20, 0x00, 0xC0, 0xA0, 0xA0, 0xC0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xF0, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0xE0, 0x20,
		0x20, 0xC0, 0x00, 0x00, 0xC0, 0xA0, 0xA0, 0xC0, 0x00, 0x00, 0xE0, 0x20,
		0x20, 0xE0, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x60, 0x80, 0x80, 0x60,
		0x18, 0xF8, 0x00, 0xE8, 0x00, 0x00, 0xE0, 0x20, 0x20, 0xE0, 0x00, 0x00,
		0xC0, 0x20, 0x20, 0xF8, 0x00, 0x00, 0xC0, 0xA0, 0xA0, 0xC0, 0x00, 0x00,
		0xC0, 0x20, 0x20, 0xF8, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x01,
		0x00, 0x00, 0x0F, 0x02, 0x02, 0x01, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02,
		0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x02, 0x02,
		0x01, 0x00, 0x00, 0x03, 0x02, 0x02, 0x03, 0x00, 0x00, 0x03, 0x02, 0x02,
		0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x00,
		0x01, 0x02, 0x02, 0x02, 0x00, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x02, 0x02, 0x02, 0x01, 0x00, 0x00, 0x0F, 0x02, 0x02, 0x01, 0x00, 0x00,
		0x01, 0x02, 0x02, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
		0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x03, 0x00, 0x03,
		0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0x02, 0x02, 0x03,
		0x00, 0x00, 0x01, 0x02, 0x02, 0x02, 0x00, 0x00, 0x01, 0x02, 0x02, 0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ]

class oled_ssd1306():
    
    self.__init__(self, interface= 1, scl= 7, sda= 6, frq= 1200000, address= 0x3C):
        
        self.oledI2C = I2C(id=interface, scl=Pin(scl), sda=Pin(sda), freq=frq)
        self._i2caddr = address


    self.oled_ssd1306() {
        common_init();
        _i2caddr = 0;
        _i2cspeed = 400000;
    }

    self.common_init(void) {
        oledI2C = NULL
        _i2caddr = 0
        _i2cspeed = 0

        self.i2c_oled_constructor(128, 64)

    }

    self.i2c_oled_constructor(self, width, height)
        _width = WIDTH = width
        _height = HEIGHT = height

        rotation = 0
        cursor_y = cursor_x = 0
        textsize = 1
        textcolor = textbgcolor = WHITE
        wrap = 1
    

    self.oled_begin(self)
        oledI2C.begin()
        oledI2C.setClock(_i2cspeed)
        
        i2c_oled_init()

    


    self.sendCommand(self, command) {

        commandbytes[2]

        commandbytes[0] = COMMAND_MODE
        commandbytes[1] = command

        self.oledI2C.beginTransmission(_i2caddr)
        self.oledI2C.write(commandbytes,2)
        self.oledI2C.endTransmission()

    }
    self.sendData(self, data) {

        char databytes[2];

        databytes[0] = DATA_MODE;
        databytes[1] = data;

        oledI2C->beginTransmission(_i2caddr);
        oledI2C->write(databytes,2);
        oledI2C->endTransmission();
    }

    self.sendCommandMulti(self, char* commands, uint8_t len) {

        uint16_t adress_command_length = len + 1;

        char *buffer = (char *)malloc( adress_command_length);
        memcpy(&buffer[1], commands, len);

        buffer[0] = COMMAND_MODE_MULTI; // Continous stream of commands

        oledI2C->beginTransmission(_i2caddr);
        oledI2C->write(buffer, adress_command_length);
        oledI2C->endTransmission();
    }

    self.sendDataMulti(uint8_t* data, uint8_t len) {

        uint16_t adress_data_length = len + 1;

        char *send_buffer = (char *)malloc( adress_data_length);
        memcpy(&send_buffer[1], data, len);

        send_buffer[0] = DATA_MODE; // Continous stream of data

        oledI2C->beginTransmission(_i2caddr);
        oledI2C->write(&send_buffer[0], adress_data_length);
        oledI2C->endTransmission();

    }


    self.i2c_oled_init() {

        // Turn display off
        sendCommand(SSD1306_DISPLAYOFF);
        sendCommand(0x00);

        sendCommand(SSD1306_SETDISPLAYCLOCKDIV);
        sendCommand(0xF0);

        sendCommand(SSD1306_SETMULTIPLEX);
        sendCommand(0x3F);

        setDisplayOffset(0x00);

        setStart_line(0x00);

        // We use internal charge pump
        sendCommand(SSD1306_CHARGEPUMP);
        sendCommand(0x14);

        // Horizontal memory mode
        setHorisontal_mode();

        sendCommand(SSD1306_SEGREMAP | 0x1);

        sendCommand(SSD1306_COMSCANDEC);

        sendCommand(SSD1306_SETCOMPINS);
        sendCommand(0x12);

        //	setCom_pins(0x12);

        // Max contrast
        setBrightness(200);

        sendCommand(SSD1306_SETPRECHARGE);
        sendCommand(0xF1);

        sendCommand(SSD1306_SETVCOMDETECT);
        sendCommand(0x40);

        sendCommand(SSD1306_DISPLAYALLON_RESUME);

        // Non-inverted display
        sendCommand(SSD1306_NORMALDISPLAY);

        // Turn display back on
        sendCommand(SSD1306_DISPLAYON);
    }

    self.i2c_oled_invert_display(uint8_t inverted) {
        if (inverted) {
            sendCommand(SSD1306_INVERTDISPLAY);
        } else {
            sendCommand(SSD1306_NORMALDISPLAY);
        }
    }


    self.sendFrame_buffer() {

        sendCommand(SSD1306_COLUMNADDR);
        sendCommand(0);   // Column start address (0 = reset)
        sendCommand(MAX_COL); // Column end address (127 = reset)

        sendCommand(MAX_PAGE);
        sendCommand(0); // Page start address (0 = reset)
        sendCommand(7); // Page end address

        uint16_t data_counter = 0;

        for (uint16_t i=0; i<(WIDTH * HEIGHT / 8); i++) {
            oledI2C->beginTransmission(_i2caddr);
            oledI2C->write(DATA_MODE);
            for (uint8_t x=0; x<16; x++) {
                oledI2C->write(buffer[data_counter++]);
                i++;
            }
            i--;
            oledI2C->endTransmission();
        }
    }

    self.i2c_oled_display(void) {
        i2c_oled_display_off();

        //	sendCommand(0x00 | 0x0);  // low col = 0
        //	sendCommand(0x10 | 0x0);  // hi col = 0


        setPage_addres(0, MAX_PAGE);      // all pages
        setColumn_addres(0, MAX_COL); // all columns

        sendCommand(0x40 | 0x0); // line #0

        oledI2C->beginTransmission(_i2caddr);
        oledI2C->write(DATA_MODE);

        for (uint16_t i = 0; i < (128 * 64 / 8); i++) {
            //		for (uint8_t x = 0; x < 16; x++) {
            oledI2C->write(buffer[i]);

            //		}
        }
        oledI2C->endTransmission();

        i2c_oled_display_on();
    }

    self.clearDisplay_buffer() {
        memset(buffer, 0, SSD1306_BUFFERSIZE);
    }
    self.displayClear() {

        sendCommand(SSD1306_COLUMNADDR);
        sendCommand(0);   // Column start address (0 = reset)
        sendCommand(MAX_COL); // Column end address (127 = reset)

        sendCommand(MAX_PAGE);
        sendCommand(0); // Page start address (0 = reset)
        sendCommand(7); // Page end address

        for (uint16_t i=0; i<(WIDTH * HEIGHT / 8); i++) {
            oledI2C->beginTransmission(_i2caddr);
            oledI2C->write(DATA_MODE);
            for (uint8_t x=0; x<16; x++) {
                oledI2C->write(0x00);
                i++;
            }
            i--;
            oledI2C->endTransmission();
        }
    }

    self.setCursor(uint8_t row, uint8_t col) {
        if (row >= HEIGHT/8) {
            row = HEIGHT/8 - 1;
        }
        if (col >= WIDTH) {
            col = WIDTH - 1;
        }
        _height = row;	// row is 8 pixels tall; must set to byte sized row
        _width = col;	// col is 1 pixel wide; can set to any pixel column

        sendCommand(SSD1306_SETLOWCOLUMN | (col & 0XF));
        sendCommand(SSD1306_SETHIGHCOLUMN | (col >> 4));
        sendCommand(SSD1306_SETSTARTPAGE | row);
    }

    self.setAddressingMode(uint8_t mode)
    {
        switch(mode){

        case PAGE_MODE:
            set_page_mode();
            break;
        case HORIZONTAL_ADDRESSING_MODE:
            set_page_mode();
            break;
        case VERTICAL_ADDRESSING_MODE:
            set_page_mode();
            break;
        };
    }

    self.set_page_mode() {
        sendCommand(SET_MEMORY_ADDRESSING_MODE); 	//set addressing mode
        sendCommand(PAGE_MODE); 			        //set page addressing mode
    }

    self.setHorisontal_mode() {
        sendCommand(SET_MEMORY_ADDRESSING_MODE); 	//set addressing mode
        sendCommand(HORIZONTAL_ADDRESSING_MODE); //set horizontal addressing mode
    }
    self.set_vertical_mode() {
        sendCommand(SET_MEMORY_ADDRESSING_MODE); 	//set addressing mode
        sendCommand(VERTICAL_ADDRESSING_MODE); //set horizontal addressing mode
    }

    self.setBrightness(unsigned char brightness) {
        sendCommand(SET_CONTRAST);
        sendCommand(brightness);
    }

    self.setStart_line(uint8_t start_line) {
        char data[2] = { SSD1306_SETSTARTLINE, start_line };
        sendCommandMulti(data, 2);
    }

    self.setPage_addres(uint8_t start, uint8_t end) {
        char data[3] = { SET_PAGE_ADDRESS, start, end };
        sendCommandMulti(data, 3);
    }

    self.setColumn_addres(uint8_t start, uint8_t end) {
        char data[3] = { SET_COLUMN_ADDRESS, start, end };
        sendCommandMulti(data, 3);
    }

    self.setDisplayOffset(uint8_t offset_value) {
        sendCommand(SSD1306_SETDISPLAYOFFSET);
        sendCommand(offset_value); //0x00
    }

    self.i2c_oled_display_on() {
        sendCommand(SET_DISPLAY_POWER_ON);
    }

    self.i2c_oled_display_off() {
        sendCommand(SET_DISPLAY_POWER_OFF);
    }

    self.i2c_oled_display_power(uint8_t on) {
        if (on) {
            i2c_oled_display_on();
        } else {
            i2c_oled_display_off();
        }
    }

    self.setCom_pins(uint8_t com_pins) {

        char *commands = (char *)malloc(2);

        //		commands[0] = COMMAND_MODE;
        commands[0] = SSD1306_SETCOMPINS;
        commands[1] = com_pins;

        sendCommandMulti(&commands[0], sizeof(commands));

        //	free(&send_buffer);
    }




    //SCROLLING FUNCTION


    // OTHER WRITE FUNCTION

    self.write(uint8_t c) {
        if (textSize_ == 1) {		// dedicated code since it's 4x faster than scaling

            if (col_ >= SSD1306_LCDWIDTH) return 0;
            col_ += 7;	// x7 font
            if (c < 32 || c > 127) c = 127;
            c -= 32;
            uint8_t *base = font + 5 * c;
            for (uint8_t i = 0; i < 5; i++ ) {
                uint8_t b = pgm_read_byte(base + i);
                sendData(b);
            }
            for (uint8_t i=0; i<textSpacing_; i++) {
                if (col_ >= SSD1306_LCDWIDTH) break;
                col_++;
                sendData(0);	// textSpacing_ pixels of blank space between characters
            }

        } else {                      // scale characters (up to 8X)

            uint8_t sourceSlice, targetSlice, sourceBitMask, targetBitMask, extractedBit, targetBitCount;
            uint8_t startRow = row_;
            uint8_t startCol = col_;

            for (uint8_t irow = 0; irow < textSize_; irow++) {
                if (row_+irow > SSD1306_LCDWIDTH - 1) break;
                if (irow > 0) setCursor(startRow+irow, startCol);
                for (uint8_t iSlice=0; iSlice<5; iSlice++) {
                    sourceSlice = pgm_read_byte(font + 5 * (c-32) + iSlice);
                    targetSlice = 0;
                    targetBitMask = 0x01;
                    sourceBitMask = 0x01 << (irow*8/textSize_);
                    targetBitCount = textSize_*7 - irow*8;
                    do {
                        extractedBit = sourceSlice & sourceBitMask;
                        for (uint8_t i=0; i<textSize_; i++) {
                            if (extractedBit != 0) targetSlice |= targetBitMask;
                            targetBitMask <<= 1;
                            targetBitCount--;
                            if (targetBitCount % textSize_ == 0) {
                                sourceBitMask <<= 1;
                                break;
                            }
                            if (targetBitMask == 0) break;
                        }
                    } while (targetBitMask != 0);

                    oledI2C->beginTransmission(_i2caddr);
                    oledI2C->write(DATA_MODE);
                    for (uint8_t i=0; i<textSize_; i++) {
                        oledI2C->write(targetSlice);
                    }
                    oledI2C->endTransmission();


                }
            }
            setCursor(startRow, startCol + 5*textSize_ + textSpacing_);
        }

        return 1;

    }
    //------------------------------------------------------------------------------
    self.write(const char* s) {
        size_t n = strlen(s);
        for (size_t i = 0; i < n; i++) {
            write(s[i]);
        }
        return n;
    }


    // the most basic function, set a single pixel
    self.i2c_oled_drawPixel(uint8_t x, uint8_t y, uint8_t color) {
        if ((x < 0) || (x >= i2c_oled_width()) || (y < 0)
                || (y >= i2c_oled_height()))
            return;

        // check rotation, move pixel around if necessary
        switch (getRotation()) {
        case 1:
            swap(x, y)
            ;
            x = WIDTH - x - 1;
            break;
        case 2:
            x = WIDTH - x - 1;
            y = HEIGHT - y - 1;
            break;
        case 3:
            swap(x, y)
            ;
            y = HEIGHT - y - 1;
            break;
        }
        // x is which column
        if (color == WHITE)
            buffer[x + (y / 8) * 128] |= bit((y % 8));
        else
            buffer[x + (y / 8) * 128] &= ~bit((y % 8));
    }

    self.i2c_oled_display_area_clear(uint8_t x, uint8_t y, uint8_t w, uint8_t h) {
        i2c_oled_fillRect(x, y, w, h, BLACK);
    }

    self.i2c_oled_drawBitmap(uint8_t x, uint8_t y, const uint8_t *bitmap, uint8_t w,
            uint8_t h, uint8_t color) {
        for (uint8_t j = 0; j < h; j++) {
            for (uint8_t i = 0; i < w; i++) {
                if (pgm_read_byte(bitmap + i + (j/8)*w) & bit(j % 8)) {
                    i2c_oled_drawPixel(x + i, y + j, color);
                }
            }
        }
    }

    // draw a character
    self.i2c_oled_drawChar(int8_t x, int8_t y, char *c, int8_t color,
            int8_t bg, uint8_t size) {

        if ((x >= _width) || // Clip right
                (y >= _height) || // Clip bottom
                ((x + 5 * size - 1) < 0) || // Clip left
                ((y + 8 * size - 1) < 0))   // Clip top
            return;

        uint8_t cr = *c;

        for (int8_t i = 0; i < 6; i++) {
            uint8_t line;
            if (i == 5)
                line = 0x0;
            else
                //line = ASCII[cr-0x20][i];
                line = pgm_read_byte(BasicFont + (cr * 5) + i);

            for (int8_t j = 0; j < 8; j++) {
                if (line & 0x1) {
                    if (size == 1) // default size
                        i2c_oled_drawPixel(x + i, y + j, color);
                    else {  // big size
                        i2c_oled_fillRect(x + (i * size), y + (j * size), size,
                                size, color);
                    }
                } else if (bg != color) {
                    if (size == 1) // default size
                        i2c_oled_drawPixel(x + i, y + j, bg);
                    else {  // big size
                        i2c_oled_fillRect(x + i * size, y + j * size, size, size,
                                bg);
                    }
                }
                line >>= 1;
            }
        }
    }

    self.i2c_oled_setTextSize(uint8_t s) {
        textsize = (s > 0) ? s : 1;
    }

    self.i2c_oled_setCursor(uint8_t x, uint8_t y) {
        cursor_x = x;
        cursor_y = y;
    }

    self.i2c_oled_setTextColorc(uint8_t c) {
        textcolor = c;
        textbgcolor = c;
        // for 'transparent' background, we'll set the bg
        // to the same as fg instead of using a flag
    }

    self.i2c_oled_setTextColor(uint8_t c, uint8_t b) {
        textcolor = c;
        textbgcolor = b;
    }

    self.i2c_oled_setTextWrap(uint8_t w) {
        wrap = w;
    }

    // draw a rectangle
    self.i2c_oled_drawRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h,
            uint8_t color) {
        i2c_oled_drawFastHLine(x, y, w, color);
        i2c_oled_drawFastHLine(x, y + h - 1, w, color);
        i2c_oled_drawFastVLine(x, y, h, color);
        i2c_oled_drawFastVLine(x + w - 1, y, h, color);
    }

    self.i2c_oled_fillRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h,
            uint8_t color) {
        // stupidest version - update in subclasses if desired!
        for (uint8_t i = x; i < x + w; i++) {
            i2c_oled_drawFastVLine(i, y, h, color);
        }
    }

    self.i2c_oled_drawFastVLine(uint8_t x, uint8_t y, uint8_t h, uint8_t color) {
        // stupidest version - update in subclasses if desired!
        i2c_oled_drawLine(x, y, x, y + h - 1, color);
    }

    self.i2c_oled_drawFastHLine(uint8_t x, uint8_t y, uint8_t w, uint8_t color) {
        // stupidest version - update in subclasses if desired!
        i2c_oled_drawLine(x, y, x + w - 1, y, color);
    }

    // bresenham's algorithm - thx wikpedia
    self.i2c_oled_drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1,
            uint8_t color) {
        int16_t steep = abs(y1 - y0) > abs(x1 - x0);
        if (steep) {
            swap(x0, y0);
            swap(x1, y1);
        }

        if (x0 > x1) {
            swap(x0, x1);
            swap(y0, y1);
        }

        int16_t dx, dy;
        dx = x1 - x0;
        dy = abs(y1 - y0);

        int16_t err = dx / 2;
        int16_t ystep;

        if (y0 < y1) {
            ystep = 1;
        } else {
            ystep = -1;
        }

        for (; x0 <= x1; x0++) {
            if (steep) {
                i2c_oled_drawPixel(y0, x0, color);
            } else {
                i2c_oled_drawPixel(x0, y0, color);
            }
            err -= dy;
            if (err < 0) {
                y0 += ystep;
                err += dx;
            }
        }
    }

    // draw a rounded rectangle!
    self.i2c_oled_drawRoundRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h,
            uint8_t r, uint8_t color) {
        // smarter version
        i2c_oled_drawFastHLine(x + r, y, w - 2 * r, color); // Top
        i2c_oled_drawFastHLine(x + r, y + h - 1, w - 2 * r, color); // Bottom
        i2c_oled_drawFastVLine(x, y + r, h - 2 * r, color); // Left
        i2c_oled_drawFastVLine(x + w - 1, y + r, h - 2 * r, color); // Right
        // draw four corners
        i2c_oled_drawCircleHelper(x + r, y + r, r, 1, color);
        i2c_oled_drawCircleHelper(x + w - r - 1, y + r, r, 2, color);
        i2c_oled_drawCircleHelper(x + w - r - 1, y + h - r - 1, r, 4, color);
        i2c_oled_drawCircleHelper(x + r, y + h - r - 1, r, 8, color);
    }

    // fill a rounded rectangle!
    self.i2c_oled_fillRoundRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h,
            uint8_t r, uint8_t color) {
        // smarter version
        i2c_oled_fillRect(x + r, y, w - 2 * r, h, color);

        // draw four corners
        i2c_oled_fillCircleHelper(x + w - r - 1, y + r, r, 1, h - 2 * r - 1, color);
        i2c_oled_fillCircleHelper(x + r, y + r, r, 2, h - 2 * r - 1, color);
    }

    // draw a triangle!
    self.i2c_oled_drawTriangle(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1,
            uint8_t x2, uint8_t y2, uint8_t color) {
        i2c_oled_drawLine(x0, y0, x1, y1, color);
        i2c_oled_drawLine(x1, y1, x2, y2, color);
        i2c_oled_drawLine(x2, y2, x0, y0, color);
    }

    // fill a triangle!
    self.i2c_oled_fillTriangle(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1,
            uint8_t x2, uint8_t y2, uint8_t color) {

        int16_t a, b, y, last;

        // Sort coordinates by Y order (y2 >= y1 >= y0)
        if (y0 > y1) {
            swap(y0, y1);
            swap(x0, x1);
        }
        if (y1 > y2) {
            swap(y2, y1);
            swap(x2, x1);
        }
        if (y0 > y1) {
            swap(y0, y1);
            swap(x0, x1);
        }

        if (y0 == y2) { // Handle awkward all-on-same-line case as its own thing
            a = b = x0;
            if (x1 < a)
                a = x1;
            else if (x1 > b)
                b = x1;
            if (x2 < a)
                a = x2;
            else if (x2 > b)
                b = x2;
            i2c_oled_drawFastHLine(a, y0, b - a + 1, color);
            return;
        }

        int16_t dx01 = x1 - x0, dy01 = y1 - y0, dx02 = x2 - x0, dy02 = y2 - y0,
                dx12 = x2 - x1, dy12 = y2 - y1, sa = 0, sb = 0;

        // For upper part of triangle, find scanline crossings for segments
        // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1
        // is included here (and second loop will be skipped, avoiding a /0
        // error there), otherwise scanline y1 is skipped here and handled
        // in the second loop...which also avoids a /0 error here if y0=y1
        // (flat-topped triangle).
        if (y1 == y2)
            last = y1;   // Include y1 scanline
        else
            last = y1 - 1; // Skip it

        for (y = y0; y <= last; y++) {
            a = x0 + sa / dy01;
            b = x0 + sb / dy02;
            sa += dx01;
            sb += dx02;
            /* longhand:
             a = x0 + (x1 - x0) * (y - y0) / (y1 - y0);
             b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
             */
            if (a > b)
                swap(a, b);
            i2c_oled_drawFastHLine(a, y, b - a + 1, color);
        }

        // For lower part of triangle, find scanline crossings for segments
        // 0-2 and 1-2.  This loop is skipped if y1=y2.
        sa = dx12 * (y - y1);
        sb = dx02 * (y - y0);
        for (; y <= y2; y++) {
            a = x1 + sa / dy12;
            b = x0 + sb / dy02;
            sa += dx12;
            sb += dx02;
            /* longhand:
             a = x1 + (x2 - x1) * (y - y1) / (y2 - y1);
             b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
             */
            if (a > b)
                swap(a, b);
            i2c_oled_drawFastHLine(a, y, b - a + 1, color);
        }
    }

    // draw a circle outline
    self.i2c_oled_drawCircle(uint8_t x0, uint8_t y0, uint8_t r, uint8_t color) {
        int16_t f = 1 - r;
        int16_t ddF_x = 1;
        int16_t ddF_y = -2 * r;
        int16_t x = 0;
        int16_t y = r;

        i2c_oled_drawPixel(x0, y0 + r, color);
        i2c_oled_drawPixel(x0, y0 - r, color);
        i2c_oled_drawPixel(x0 + r, y0, color);
        i2c_oled_drawPixel(x0 - r, y0, color);

        while (x < y) {
            if (f >= 0) {
                y--;
                ddF_y += 2;
                f += ddF_y;
            }
            x++;
            ddF_x += 2;
            f += ddF_x;

            i2c_oled_drawPixel(x0 + x, y0 + y, color);
            i2c_oled_drawPixel(x0 - x, y0 + y, color);
            i2c_oled_drawPixel(x0 + x, y0 - y, color);
            i2c_oled_drawPixel(x0 - x, y0 - y, color);
            i2c_oled_drawPixel(x0 + y, y0 + x, color);
            i2c_oled_drawPixel(x0 - y, y0 + x, color);
            i2c_oled_drawPixel(x0 + y, y0 - x, color);
            i2c_oled_drawPixel(x0 - y, y0 - x, color);

        }
    }

    self.i2c_oled_drawCircleHelper(uint8_t x0, uint8_t y0, uint8_t r,
            uint8_t cornername, uint8_t color) {
        int16_t f = 1 - r;
        int16_t ddF_x = 1;
        int16_t ddF_y = -2 * r;
        int16_t x = 0;
        int16_t y = r;

        while (x < y) {
            if (f >= 0) {
                y--;
                ddF_y += 2;
                f += ddF_y;
            }
            x++;
            ddF_x += 2;
            f += ddF_x;
            if (cornername & 0x4) {
                i2c_oled_drawPixel(x0 + x, y0 + y, color);
                i2c_oled_drawPixel(x0 + y, y0 + x, color);
            }
            if (cornername & 0x2) {
                i2c_oled_drawPixel(x0 + x, y0 - y, color);
                i2c_oled_drawPixel(x0 + y, y0 - x, color);
            }
            if (cornername & 0x8) {
                i2c_oled_drawPixel(x0 - y, y0 + x, color);
                i2c_oled_drawPixel(x0 - x, y0 + y, color);
            }
            if (cornername & 0x1) {
                i2c_oled_drawPixel(x0 - y, y0 - x, color);
                i2c_oled_drawPixel(x0 - x, y0 - y, color);
            }
        }
    }

    self.i2c_oled_fillCircle(uint8_t x0, uint8_t y0, uint8_t r, uint8_t color) {
        i2c_oled_drawFastVLine(x0, y0 - r, 2 * r + 1, color);
        i2c_oled_fillCircleHelper(x0, y0, r, 3, 0, color);
    }

    // used to do circles and roundrects!
    self.i2c_oled_fillCircleHelper(uint8_t x0, uint8_t y0, uint8_t r,
            uint8_t cornername, int16_t delta, uint8_t color) {

        int16_t f = 1 - r;
        int16_t ddF_x = 1;
        int16_t ddF_y = -2 * r;
        int16_t x = 0;
        int16_t y = r;

        while (x < y) {
            if (f >= 0) {
                y--;
                ddF_y += 2;
                f += ddF_y;
            }
            x++;
            ddF_x += 2;
            f += ddF_x;

            if (cornername & 0x1) {
                i2c_oled_drawFastVLine(x0 + x, y0 - y, 2 * y + 1 + delta, color);
                i2c_oled_drawFastVLine(x0 + y, y0 - x, 2 * x + 1 + delta, color);
            }
            if (cornername & 0x2) {
                i2c_oled_drawFastVLine(x0 - x, y0 - y, 2 * y + 1 + delta, color);
                i2c_oled_drawFastVLine(x0 - y, y0 - x, 2 * x + 1 + delta, color);
            }
        }
    }

    self.i2c_oled_setHorizontalScrollProperties(bool direction,
            unsigned char startPage, unsigned char endPage,
            unsigned char scrollSpeed) {
        /*
         Use the following defines for 'direction' :

         Scroll_Left
         Scroll_Right

         Use the following defines for 'scrollSpeed' :

         Scroll_2Frames
         Scroll_3Frames
         Scroll_4Frames
         Scroll_5Frames
         Scroll_25Frames
         Scroll_64Frames
         Scroll_128Frames
         Scroll_256Frames

         */

        if (Scroll_Right == direction) {
            //Scroll Right
            sendCommand(Right_Horizontal_Scroll_Cmd);
        } else {
            //Scroll Left
            sendCommand(Left_Horizontal_Scroll_Cmd);

        }
        sendCommand(Dummy_Byte_0x00);  //Dummy byte
        sendCommand(startPage);
        sendCommand(scrollSpeed);
        sendCommand(endPage);
        sendCommand(Dummy_Byte_0x00);  //Dummy byte
        sendCommand(Dummy_Byte_0xFF);  //Dummy byte
    }

    self.i2c_oled_activateScroll() {
        sendCommand(Activate_Scroll_Cmd);
    }

    self.i2c_oled_deactivateScroll() {
        sendCommand(Deactivate_Scroll_Cmd);
    }

    self.i2c_oled_setNormalDisplay() {
        sendCommand(GOFi2cOLED_Normal_Display_Cmd);
    }

    self.i2c_oled_setInverseDisplay() {
        sendCommand(GOFi2cOLED_Inverse_Display_Cmd);
    }

    self.setRotation(uint8_t x) {
        x %= 4;  // cant be higher than 3
        rotation = x;
        switch (x) {
        case 0:
        case 2:
            _width = WIDTH;
            _height = HEIGHT;
            break;
        case 1:
        case 3:
            _width = HEIGHT;
            _height = WIDTH;
            break;
        }
    }

    self.getRotation(void) {
        rotation %= 4;
        return rotation;
    }

    // return the size of the display which depends on the rotation!
    self.i2c_oled_width(void) {
        return _width;
    }

    self.i2c_oled_height(void) {
        return _height;
    }


    // Posignle solution if(strcmp(a,"ab")==0)
    self.i2c_oled_drawString(int16_t x, int16_t y, char *c, uint8_t color, uint8_t bg, uint8_t size) {
        uint8_t wrap=0;

        while(*c){
            if (c == "\n") {
                y += size*8;
                x = 0;
            }
            else if (c == "\r") {
                // skip em
            }
            else {
                i2c_oled_drawChar(x,y,c,color,bg,size);
                x += size*6;
                if (wrap && (x > (COLUMNS - size*6))) {
                    y += size*8;
                    x = 0;
                }
            }
            *c++;
        }
    }


    #define PI 3.1415926535897932384626433832795
    #define HALF_PI 1.5707963267948966192313216916398
    #define TWO_PI 6.283185307179586476925286766559
    #define DEG_TO_RAD 0.017453292519943295769236907684886
    #define RAD_TO_DEG 57.295779513082320876798154814105
    #define EULER 2.718281828459045235360287471352

    self.drawCircle(int x, int y, int radius, int color)
    {
        for (int i=0; i<360; i++)  // a bigger radius might need more steps
        {
            double radians = i * PI / 180;
            double px = x + radius * cos(radians);
            double py = y + radius * sin(radians);
            i2c_oled_drawPixel(px, py, color);
        }
    }

    self.drawPieSlice(int x, int y, int radius, int color, int startAngle, int EndAngle)
    {
        for (int i=startAngle; i<EndAngle; i++)
        {
            double radians = i * PI / 180;
            double px = x + radius * cos(radians);
            double py = y + radius * sin(radians);
            i2c_oled_drawPixel(px, py, color);
        }
    }

    void self.ddrawCircle(int x, int y, int radius, int color)
    {
        drawPieSlice(x, y, radius, color, 0, 360);
    }

